{"meta":{"title":"cokezhang","subtitle":"","description":"","author":"cokezhang","url":"http://skyingzz.github.io","root":"/"},"posts":[{"tags":[{"name":"golang","slug":"golang","permalink":"http://skyingzz.github.io/tags/golang/"},{"name":"prometheus","slug":"prometheus","permalink":"http://skyingzz.github.io/tags/prometheus/"},{"name":"监控","slug":"监控","permalink":"http://skyingzz.github.io/tags/%E7%9B%91%E6%8E%A7/"}],"title":"浅谈prometheus client golang","date":"2020/01/19","text":"含类型精讲+接口示例+源码节选 Prometheus：prometheus是什么，网上已经有很多文章了，prometheus的部署和启动可以参照这个链接。prometheus为使用者提供了http接口，使用者可以使用PromQl通过get或post来从prometheus进行query。prometheus http api传送示例： Client golang四种类型：counter计数器，并且只能增长和重置。例如：一个网站的总访问量，机器的运行时长 gauge测量值，或瞬时记录值，可以增加，也可以减少。例如：一个视频的同时观看人数，当前运行的进程数 histogram 直方图，一个histogram会生成三个指标，分别是_count，_sum，_bucket。暂时为了好理解，先把_sum指标理解为Gauge，然后_count指标就是对Gauge值修改的总次数，而_bucket指标分成了几个桶子，把每次修改的值放进桶子里，不过会把值分几个层次，进入不同的桶，每个桶子里面的个数，就是直方图的纵坐标（实际情况是这个桶之前所有桶里面的个数是这个桶的纵坐标），而桶子的划分条件，就是横坐标。 举个铁球做例子，我们一共有1000个大小不同的铁球，质量从1kg-100kg不等，假设我分5个桶，每个桶存储不同质量的铁球，第一个桶0-20kg，第二个20-40kg，后面依此。然后1000个铁球，就是histogram的count，而1000个铁球的总质量就是histogram的sum，那么bucket就是那五个桶，当然几个桶，桶的规则怎样都是可以设计的，这五个桶每个的0-20,20-40…就是横坐标，而每个桶中的个数，就是纵坐标。根据这些数据就可以形成一个直方图。 因为直方图能够分出数据的质量，所以应用直方图的例子如：页面的响应时间，一块业务代码的时延 一个不错的例子：传送门 刚接触的可能会懵懵的，不过不太复杂，建议多去实践一下。summary 概要，summary和histogram类似也会产生三个指标，分别是_count，_sum，和{quantile} ,count和sum与histogram的概念相同，quantile的含义是分位数，我们都知道中位数，那么中位数其实就是一个五分quantile，而summary可以在定义时指定很多分位数，如五分数，九分数，九九分数。九分数的概念就是比这个数小的数占百分之九十。 summary和histogram类似也可以用来描述页面响应时间这类型的值，但差别是，histogram可以很容易看出来长尾值，比如投票很多时候都是去掉一个最高分，去掉一个最低分这种，长尾值就是很影响平均数的值，所有直方图能够很容易分析出问题数据。 而summary更能发现百分之多少的页面响应时间是多少，更能分析出页面响应时间的总体情况。比较 summary和histogram都很容易看出平均数(即_sum/_count)，但是histogram容易发现影响平均数的极端值，而histogram可以直接得到分位数，两种结构可以由开发者根据数据需求自行抉择。 histogram由clinet go直接算出分位数，而summary虽然可以算出分位数，但是更多是由开发者计算，或者调用prometheus的api获取histogram的分位数，prometheus处理函数传送门。 四种类型的接口(go)：下面图片可传送： Countercounter.Inc(), counter.Add(123) Gaugegauge.Set(), gauge.Inc(), gauge.Dec(), gauge.Add(123) , gauge.Sub(321) Histogramhistogram.Observer(123)//添加此数据到此histogram实例（使其观察） Summarysummary.Observer(123) 共有接口123456type Metric interface &#123; //获取此metric的描述 Desc() *Desc //转化为proto格式的Metric，返回 Write(*dto.Metric) error //dto \"github.com/prometheus/client_model/go\"&#125; 四种类型使用：client golang的代码均是安全的，使用了sync库下的读写锁和CAS原子操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 package main //不是伪代码，可以直接go run import ( \"net/http\"\"time\"\"log\"\"math\" \"github.com/prometheus/client_golang/prometheus\" \"github.com/prometheus/client_golang/prometheus/promhttp\" ) var ( MyTestCounter = prometheus.NewCounter(prometheus.CounterOpts&#123; //因为Name不可以重复，所以建议规则为：\"部门名_业务名_模块名_标量名_类型\" Name: \"my_test_counter\", //唯一id，不可重复Register()，可以Unregister() Help: \"my test counter\", //对此Counter的描述&#125;)MyTestGauge = prometheus.NewGauge(prometheus.GaugeOpts&#123; Name: \"my_test_gauge\", Help: \"my test gauge\",&#125;)MyTestHistogram = prometheus.NewHistogram(prometheus.HistogramOpts&#123; Name: \"my_test_histogram\", Help: \"my test histogram\", Buckets: prometheus.LinearBuckets(20, 5, 5), //第一个桶20起，每个桶间隔5，共5个桶。 所以20, 25, 30, 35, 40&#125;)MyTestSummary = prometheus.NewSummary(prometheus.SummaryOpts&#123; Name: \"my_test_summary\", Help: \"my test summary\", Objectives: map[float64]float64&#123;0.5: 0.05, 0.9: 0.01, 0.99: 0.001&#125;, //返回五分数， 九分数， 九九分数&#125;) ) func main() &#123; //不能注册多次Name相同的Metrics //MustRegister注册失败将直接panic()，如果想捕获error，建议使用Register()prometheus.MustRegister(MyTestCounter)prometheus.MustRegister(MyTestGauge)prometheus.MustRegister(MyTestHistogram)prometheus.MustRegister(MyTestSummary) go func()&#123; var i float64 for &#123; i++ MyTestCounter.Add(10000) //每次加常量 MyTestGauge.Add(i) //每次加增量 MyTestHistogram.Observe(30 + math.Floor(120*math.Sin(float64(i)*0.1))/10) //每次观察一个18 - 42的量 MyTestSummary.Observe(30 + math.Floor(120*math.Sin(float64(i)*0.1))/10) time.Sleep(time.Second) &#125; &#125;() http.Handle(\"/metrics\", promhttp.Handler()) log.Fatal(http.ListenAndServe(\"0.0.0.0:8080\", nil))//多个进程不可监听同一个端口 &#125; 我们看一下瞬时的值(运行之后在控制台输入curl 127.0.0.1:8080/metrics即可获取metrics)： 我们重点看下histogram_bucket，le=”20”,代表0-20的值有12个，le=”25”,代表0-25的值有20个，le=”+Inf”，代表一共有55个值，和histogram的值是相同的，如果想计算30-35的值的个数，需要用le=”35” - le=”30”来获取。 summary{quantile=”0.5”},代表瞬时，中位数为32.3，summary{quantile=”0.9”}，九分数为41.5。 histogram的平均数是 sum/count = 1677.5/55 = 30.5 summary的平均数是 sum/count = 1677.5/55 = 30.5,因为他们两个每次赋的值相同，所以平均数也肯定相同。他们的区别通过上面的数据，估计读者也应该有个了解了。放上几张prometheus的图表，很好理解： 图像存在锯齿是因为prometheus默认每15s同步一次数据 Vector类型及其提供的接口：不论是Counter, Gauge, Histogram, Summary，都有自己的数组形式， 我们可以直接使用。以下是client go提供的对数组全部操作的接口。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//metricVec实现了具体结构和接口，提供给四种数组类型调用,部分接口不提供给用户//位于github.com/prometheus/client_golang/prometheus/vec.gotype metricVec struct &#123; *metricMap curry []curriedLabelValue hashAdd func(h uint64, s string) uint64 hashAddByte func(h uint64, b byte) uint64&#125;//删除匹配的labels，删除成功返回true，如果未找到则返回false，并不是error//两者的不同：// Delete用法： vec.Delete(Labels&#123;\"l1\": \"v1\", \"l2\": \"v2\"&#125;)// DeleteLabelValues用法： vec.DeleteLabelValues(\"v1\", \"v2\")//如果后者参数的顺序有问题，则返回false，而前者不会//但是与之带来的是前者的开销要比后者大，因为前者要构建Labels映射func (m *metricVec) DeleteLabelValues(lvs ...string) bool&#123;&#125;func (m *metricVec) Delete(labels Labels) bool &#123;&#125;type Observer interface &#123; Observe(float64)&#125;//XXX需要使用Counter,Gauge,Histogram,Summary来代替//以下接口实现于counter.go, gauge.go, histogram.go, summary.gotype XXXVec struct &#123; *metricVec&#125;//将返回数组实例，如 NewCounterVec，将返回一个 *CounterVec，//注意，调用时，opts 中， Histogtam的Budket不能有\"le\", Summary的quantile不能有\"quantile\"，否则painc()func NewXXXVec(opts XXXOpts, labelNames []string) *XXXVec&#123;&#125;//如果CounterVec则 TTT为Counter，GaugeVec则TTT为Gauge，Histogram和Summary则TTT为Observer//获取Counter,Gauge,Histogram或Summary，如果存在则返回，不存在则创建，如果name相同，描述不同，则返回error。//用法：// vec.GetMetricWith(Labels&#123;\"l1\": \"v1\", \"l2\": \"v2\"&#125;)// vec.GetMetricWithLabelValues(\"v1\", \"v2\")//很容易因为顺序问题而导致错误或获取不到，所以建议使用前者，但与之带来的是前者会有额外消耗//如果我们只想获取，如果获取不到不创建新的的话，那么是做不到的，不过我们不保存返回的实例就好了。如果考虑到消耗，也可以使用Delete来移除它func (v *XXXVec) GetMetricWith(labels Labels) (TTT, error)&#123;&#125;func (v *XXXVec) GetMetricWithLabelValues(lvs ...string)(TTT, error)&#123;&#125;//分别为GetMetricWith和GetMetricWithLabelValues的must形式//即如果出错则panic(),不会返回error//不建议使用must形式，因为觉得我们自己处理error的能力还是要有的，即使我们捕捉到error之后和它做相同的事func (v *XXXVec) WithLabelValues(lvs ...string) TTT&#123;&#125;func (v *XXXVec) With(labels Labels) TTT&#123;&#125;//CurryWith将根据传入的labels，进行匹配，返回xxxVec形式，xxxVec并不是数组类型！//作用为了返回子xxxVec//注意，不要对返回值进行for range，因为不是数组，并且里面的值和方法并不是公开的。//可能的使用情况：// TestHistogramVec := NewHistogramVec(HistogramVecOpts&#123;// Name : \"test_name\",// Help : \"test_help\",// Buckets: prometheus.LinearBuckets(20, 5, 5),// &#125;,[]string&#123;\"color\",\"size\",\"weight\"&#125;)// TestHistogramVecSon := CurryWith(\"color\":\"black\")func (v *XXXVec) CurryWith(labels Labels) (TTTVec, error)&#123;&#125;//CurryWith的Must形式，出现异常直接panic()func (v *XXXVec) MustCurryWith(labels Labels) TTTVec&#123;&#125; 数组的使用：1234567891011121314151617181920212223242526272829303132333435363738package main import ( \"net/http\" \"time\" \"log\" \"math\" \"github.com/prometheus/client_golang/prometheus\" \"github.com/prometheus/client_golang/prometheus/promhttp\" ) var ( MyTestHistogramVec = prometheus.NewHistogramVec(prometheus.HistogramOpts&#123; Name: \"human_weight_histogram\", Help: \"human weight histogram\", Buckets: prometheus.LinearBuckets(1, 10, 15), //第一个桶1起，每个桶间隔10, 共15个桶。 所以1,11,21,31,...,141 &#125;,[]string&#123;\"sex\",\"age\",\"race\"&#125;,) ) func main() &#123; prometheus.MustRegister(MyTestHistogramVec) go func()&#123; var i float64 for i &lt; 20 &#123; //不要太在意赋的什么值了，随便写的，主要为了了解用法 MyTestHistogramVec.With(prometheus.Labels&#123;\"sex\":\"man\",\"age\":\"20\",\"race\":\"black\"&#125;).Observe(90 + math.Floor(400*math.Sin(float64(i*127)*0.1))/10) MyTestHistogramVec.With(prometheus.Labels&#123;\"sex\":\"woman\",\"age\":\"20\",\"race\":\"black\"&#125;).Observe(70 + math.Floor(400*math.Sin(float64(i*127)*0.1))/10) MyTestHistogramVec.With(prometheus.Labels&#123;\"sex\":\"man\",\"age\":\"25\",\"race\":\"black\"&#125;).Observe(95 + math.Floor(400*math.Sin(float64(i*127)*0.1))/10) MyTestHistogramVec.With(prometheus.Labels&#123;\"sex\":\"woman\",\"age\":\"25\",\"race\":\"black\"&#125;).Observe(95 + math.Floor(400*math.Sin(float64(i*127)*0.1))/10) MyTestHistogramVec.With(prometheus.Labels&#123;\"sex\":\"man\",\"age\":\"20\",\"race\":\"yellow\"&#125;).Observe(90 + math.Floor(400*math.Sin(float64(i*127)*0.1))/10) time.Sleep(time.Second) i++ &#125; &#125;() http.Handle(\"/metrics\", promhttp.Handler()) log.Fatal(http.ListenAndServe(\"0.0.0.0:8080\", nil) &#125; 看一下结果 可以发现，有太多项了下面我们对结果进行过滤 这样就可以对数组，或者Histogram, 或者Summary进行过滤了promauto：如果你是一个懒人的话，不想去手动Registor()的话，promauto提供了这种方法。 123456789101112import ( \"github.com/prometheus/client_golang/prometheus\" \"github.com/prometheus/client_golang/prometheus/promauto\")//这时候你就不需要去调用带Registor字样的方法了。Unregistor除外！//但是因为promauto调用的是MustRegistor(xxx)，所以如果注册出现问题会直接panic()var histogram = promauto.NewHistogram(prometheus.HistogramOpts&#123; Name: \"random_numbers\", Help: \"A histogram of normally distributed random numbers.\", Buckets: prometheus.LinearBuckets(-3, .1, 61),&#125;) 1234567891011121314151617//看两个promauto的实现func NewCounterFunc(opts prometheus.CounterOpts, function func() float64) prometheus.CounterFunc &#123; g := prometheus.NewCounterFunc(opts, function) prometheus.MustRegister(g) return g&#125;func NewSummary(opts prometheus.SummaryOpts) prometheus.Summary &#123; s := prometheus.NewSummary(opts) prometheus.MustRegister(s) return s&#125;func NewHistogramVec(opts prometheus.HistogramOpts, labelNames []string) *prometheus.HistogramVec &#123; h := prometheus.NewHistogramVec(opts, labelNames) prometheus.MustRegister(h) return h&#125; Timer:原文链接 12345678910111213141516171819202122232425262728293031//原文就这么多package prometheusimport \"time\"// Timer is a helper type to time functions. Use NewTimer to create new// instances.type Timer struct &#123; begin time.Time observer Observer&#125;// 通常使用这种形式来Observe一个函数的运行时间// 已测试，非常好用// func TimeMe() &#123;// timer := NewTimer(myHistogram)// defer timer.ObserveDuration()// // Do actual work.// &#125;func NewTimer(o Observer) *Timer &#123; return &amp;Timer&#123; begin: time.Now(), observer: o, &#125;&#125;func (t *Timer) ObserveDuration() time.Duration &#123; d := time.Since(t.begin) if t.observer != nil &#123; t.observer.Observe(d.Seconds()) &#125; return d&#125; 最后附赠几个网络上文档链接https://godoc.org/github.com/prometheus/client_golang/prometheushttps://ryanyang.gitbook.io/prometheus/https://s0prometheus0io.icopy.site/docs/introduction/overview/","permalink":"http://skyingzz.github.io/2020/01/19/prometheus-client-go/","photos":[]},{"tags":[{"name":"json","slug":"json","permalink":"http://skyingzz.github.io/tags/json/"},{"name":"golang","slug":"golang","permalink":"http://skyingzz.github.io/tags/golang/"}],"title":"把json中的key转化为驼峰式(首字母大写形式)","date":"2020/01/18","text":"最近处理json数据，json中Key转化为下划线形式，在网络上找了一段时间并没有找到可以实现功能的代码~ 自己动手！ 功能：把例如 “the_red_apple”:”very_nice” 转化为 “TheRedApple”:”very_nice” 这种。 代码：https://github.com/SkyingzZ/camel_json_keys 1234567891011121314151617181920212223242526272829303132333435//下划线写法转为驼峰写法 like \"sample_test_name_balabala\" to \"SampleTestNameBalabala\"func CamelName(name string) string &#123; name = strings.Replace(name, \"_\", \" \", -1) name = strings.Title(name) return strings.Replace(name, \" \", \"\", -1)&#125;func CamelJsonKey(json_data []byte) []byte&#123; str := string(json_data) var is_quot_first bool = true //在双引号中为 false | the value in the double quotes is false var first_index int = 0 //左引号的索引 | the left quote index var second_index int = 0 //右引号的索引 | the right quote index var res_str string var the_key_index int for i, value := range str&#123; if !is_quot_first &amp;&amp; str[i] == '\"'&#123; //右引号 | if meet the right quote second_index = i is_quot_first = !is_quot_first &#125;else if is_quot_first &amp;&amp; str[i] == '\"'&#123; //左引号 | if meet the left quote first_index = i the_key_index = len(res_str) is_quot_first= !is_quot_first &#125;else if is_quot_first &amp;&amp; str[i] == ':'&#123; tmp_str := camelName(str[first_index+1: second_index]) res_str = res_str[:the_key_index]+\"\\\"\"+tmp_str+\"\\\"\" &#125;else&#123;&#125; res_str += string(value) &#125; return []byte(res_str)&#125; 效果： 原来 ==&gt; 后来 本来觉得上面这个一个for循环的代码虽然有很多数组的copy以及字符串的处理，但应该已经足够处理问题了。可终于在一个特殊的情况，遇到了一个6M大小的json字符串，此处理函数处理了10分钟。 于是对代码进行了改进，并换了一个使用map来处理的思路。下面这个代码，暂时业务中没遇到过超过ms级的情况。 同时，也得到了一点启迪，即在可以使用系统提供的底层情况下，尽量不要自己去写底层。因为不要觉得自己代码效率会超过大师。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106//下划线写法转为驼峰写法,并且将'/'字符转换为'' like \"sample_test_name_balabala/dilidili\" to \"SampleTestNameBalabalaDilidili\"//同时也会去掉左侧的全部数字 like \"361_sport\" to \"Sport\"func camelName(name string) string &#123; name = strings.Replace(name, \"_\", \" \", -1) name = strings.Replace(name, \"/\", \" \", -1) name = strings.Title(name) name = strings.Replace(name, \" \", \"\", -1) return strings.TrimLeft(name, \"0123456789\")&#125;func camelVecKey(my_vec []interface&#123;&#125;) ([]interface&#123;&#125;, error)&#123; if !strings.HasPrefix(reflect.TypeOf(my_vec).String(), \"[]\")&#123; return nil, errors.New(\"decode to vector failed\") &#125; rtn_vec := my_vec[0:0] for _, node := range my_vec&#123; if reflect.TypeOf(node) == nil&#123; continue &#125; if strings.HasPrefix(reflect.TypeOf(node).String(),\"map\")&#123; res_node, err := camelMapKey(node.(map[string]interface&#123;&#125;)) if err != nil&#123; return nil, err &#125; rtn_vec = append(rtn_vec, res_node) &#125;else if strings.HasPrefix(reflect.TypeOf(node).String(),\"[]\")&#123; res_node, err := camelVecKey(node.([]interface&#123;&#125;)) if err != nil&#123; return nil, err &#125; rtn_vec = append(rtn_vec, res_node) &#125;else&#123; rtn_vec = append(rtn_vec, node) &#125; &#125; return rtn_vec, nil&#125;func camelMapKey(my_map map[string]interface&#123;&#125;) (map[string]interface&#123;&#125;, error)&#123; if !strings.HasPrefix(reflect.TypeOf(my_map).String(), \"map\")&#123; return nil, errors.New(\"decode to map failed\") &#125; rtn_map := make(map[string]interface&#123;&#125;) for k,v := range my_map&#123; if reflect.TypeOf(v) == nil&#123; rtn_map[camelName(k)] = nil continue &#125; if strings.HasPrefix(reflect.TypeOf(v).String(),\"map\")&#123; res_map, err := camelMapKey(v.(map[string]interface&#123;&#125;)) if err != nil&#123; return nil, err &#125; rtn_map[camelName(k)] = res_map &#125; else if strings.HasPrefix(reflect.TypeOf(v).String(), \"[]\")&#123; res_node, err := camelVecKey(v.([]interface&#123;&#125;)) if err != nil&#123; return nil, err &#125; rtn_map[camelName(k)] = res_node &#125; else &#123; rtn_map[camelName(k)] = v &#125; &#125; return rtn_map, nil&#125;func CamelJsonKey(json_data []byte, is_vec bool) ([]byte, error)&#123; var my_map_vec []interface&#123;&#125; var my_map map[string]interface&#123;&#125; if is_vec &#123; err := json.Unmarshal(json_data, &amp;my_map_vec) if err != nil&#123; return []byte&#123;&#125;, errors.New(\"Unmarshal json to vector failed\") &#125; my_map_vec, err = camelVecKey(my_map_vec) if err != nil&#123; return []byte&#123;&#125;, err &#125; my_json,err :=json.Marshal(my_map_vec) if err != nil&#123; return []byte&#123;&#125;, err &#125; return my_json, err &#125; else &#123; my_map = make(map[string]interface&#123;&#125;) err := json.Unmarshal(json_data, &amp;my_map) if err != nil&#123; return []byte&#123;&#125;, errors.New(\"Unmarshal json to map failed\") &#125; my_map, err = camelMapKey(my_map) if err != nil&#123; return []byte&#123;&#125;, err &#125; my_json,err :=json.Marshal(my_map) if err != nil&#123; return []byte&#123;&#125;, err &#125; return my_json, err &#125;&#125;","permalink":"http://skyingzz.github.io/2020/01/18/camlejson/","photos":[]},{"tags":[{"name":"c++","slug":"c","permalink":"http://skyingzz.github.io/tags/c/"}],"title":"C++类的参数传递与返回值优化","date":"2018/12/03","text":"类的成员变量要设置成私有 构造函数使用初始化列表来初始化变量 构造函数传递参数时，尽量使用如下形式，因为构造函数执行两件事情，初始化和赋值，而使用如下形式，则只执行了初始化操作，减少了赋值的过程 1234567 class complex &#123; public: complex(double r = 0, double i = 0): re(r), im(i)&#123;&#125; private: double re, im; &#125;; 私有构造函数 把构造函数设置成私有后，外界将不可以创建此类的实例，但是单例模式常常这样做，因为单例模式不允许用户新建实例，但是可以获取实例 类的常量成员函数const member functions 常量成员函数如下，在函数后面加const，作用是保证函数内不会存在变量值改变的情况 123456789101112131415 double real() const &#123;return re;&#125; // 如果类的函数没有设置为常量成员函数，则类的 常量实例 来调用类的非常量成员函数时会出错，如下 class complex &#123; public: double real() &#123;return re;&#125; private: double re,im; &#125; int main() &#123; const complex c1(); cout&lt;&lt;c1.real();//此处报错，因为此处调用并不想存在变量值的修改，但是此函数并没有设置为常量成员函数，此函数并不能保证无值修改 &#125;; 传参尽量使用引用传递而不要使用值传递 尽量使用引用传递的好处是，在传递参数时，不会新建变量来存储，即省去了栈的存储空间，也省去了拷贝带来的时间消耗 12345 //尽量使用 int add(const int&amp; a, const int &amp;b); //而不是 int add(int a, int b); //当然，上面的const可以去掉，但是当不希望函数对参数的值进行修改的时候，尽量使用const 返回值传值还是 传引用？ 如果可以的情况下，返回值尽量传递引用，因为效率更高，但是有的情况必须使用值传递，比如返回的参数为函数内新建的变量，那么当此变量作为返回值被传递出去，函数外面进行调用的时候，这个变量的空间已经被释放掉了，那么调用就会出错 使用友员函数？ 尽量少的使用友员函数，因为友员函数可以调用此类的私有变量，破坏了封装性。 但是友员函数的好处是可以直接调用类的变量，不用通过函数来取，执行效率更高，开发更直接 类中传递此类的参数的函数，函数内可以使用参数的私有变量 12345678 class complex &#123; public: int func(const complex&amp; param) &#123;return param.re + param.im;&#125; private: double re,rm; &#125;; 比较合理的解释为，相同class的各个objects之间互为友员。","permalink":"http://skyingzz.github.io/2018/12/03/cpp-param/","photos":[]}]}