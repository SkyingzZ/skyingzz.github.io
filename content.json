{"meta":{"title":"cokezhang","subtitle":"","description":"","author":"cokezhang","url":"http://skyingzz.github.io","root":"/"},"posts":[{"tags":[{"name":"json","slug":"json","permalink":"http://skyingzz.github.io/tags/json/"},{"name":"golang","slug":"golang","permalink":"http://skyingzz.github.io/tags/golang/"}],"title":"把json中的key转化为驼峰式(首字母大写形式)","date":"2020/01/18","text":"最近处理json数据，json中数据下划线形式，找了半天没有找到能把下划线处理成驼峰式的代码~ 自己动手！ 功能：把例如 “the_red_apple”:”very_nice” 转化为 “TheRedApple”:”very_nice” 这种。代码：https://github.com/SkyingzZ/camel_json_keys 1234567891011121314151617181920212223242526272829303132333435 //下划线写法转为驼峰写法 like \"sample_test_name_balabala\" to \"SampleTestNameBalabala\" func CamelName(name string) string &#123; name = strings.Replace(name, \"_\", \" \", -1) name = strings.Title(name) return strings.Replace(name, \" \", \"\", -1) &#125; func CamelJsonKey(json_data []byte) []byte&#123; str := string(json_data) var is_quot_first bool = true //在双引号中为 false | the value in the double quotes is false var first_index int = 0 //左引号的索引 | the left quote index var second_index int = 0 //右引号的索引 | the right quote index var res_str string var the_key_index int for i, value := range str&#123; if !is_quot_first &amp;&amp; str[i] == '\"'&#123; //右引号 | if meet the right quote second_index = i is_quot_first = !is_quot_first &#125;else if is_quot_first &amp;&amp; str[i] == '\"'&#123; //左引号 | if meet the left quote first_index = i the_key_index = len(res_str) is_quot_first= !is_quot_first &#125;else if is_quot_first &amp;&amp; str[i] == ':'&#123; tmp_str := CamelName(str[first_index+1: second_index]) res_str = res_str[:the_key_index]+\"\\\"\"+tmp_str+\"\\\"\" &#125;else&#123;&#125; res_str += string(value) &#125; return []byte(res_str) &#125;效果： 原来 ==&gt; 后来","permalink":"http://skyingzz.github.io/2020/01/18/camlejson/","photos":[]},{"tags":[{"name":"c++","slug":"c","permalink":"http://skyingzz.github.io/tags/c/"}],"title":"C++类的参数传递与返回值优化","date":"2018/12/03","text":"类的成员变量要设置成私有 构造函数使用初始化列表来初始化变量 构造函数传递参数时，尽量使用如下形式，因为构造函数执行两件事情，初始化和赋值，而使用如下形式，则只执行了初始化操作，减少了赋值的过程 1234567 class complex &#123; public: complex(double r = 0, double i = 0): re(r), im(i)&#123;&#125; private: double re, im; &#125;; 私有构造函数 把构造函数设置成私有后，外界将不可以创建此类的实例，但是单例模式常常这样做，因为单例模式不允许用户新建实例，但是可以获取实例 类的常量成员函数const member functions 常量成员函数如下，在函数后面加const，作用是保证函数内不会存在变量值改变的情况 123456789101112131415 double real() const &#123;return re;&#125; // 如果类的函数没有设置为常量成员函数，则类的 常量实例 来调用类的非常量成员函数时会出错，如下 class complex &#123; public: double real() &#123;return re;&#125; private: double re,im; &#125; int main() &#123; const complex c1(); cout&lt;&lt;c1.real();//此处报错，因为此处调用并不想存在变量值的修改，但是此函数并没有设置为常量成员函数，此函数并不能保证无值修改 &#125;; 传参尽量使用引用传递而不要使用值传递 尽量使用引用传递的好处是，在传递参数时，不会新建变量来存储，即省去了栈的存储空间，也省去了拷贝带来的时间消耗 12345 //尽量使用 int add(const int&amp; a, const int &amp;b); //而不是 int add(int a, int b); //当然，上面的const可以去掉，但是当不希望函数对参数的值进行修改的时候，尽量使用const 返回值传值还是 传引用？ 如果可以的情况下，返回值尽量传递引用，因为效率更高，但是有的情况必须使用值传递，比如返回的参数为函数内新建的变量，那么当此变量作为返回值被传递出去，函数外面进行调用的时候，这个变量的空间已经被释放掉了，那么调用就会出错 使用友员函数？ 尽量少的使用友员函数，因为友员函数可以调用此类的私有变量，破坏了封装性。 但是友员函数的好处是可以直接调用类的变量，不用通过函数来取，执行效率更高，开发更直接 类中传递此类的参数的函数，函数内可以使用参数的私有变量 12345678 class complex &#123; public: int func(const complex&amp; param) &#123;return param.re + param.im;&#125; private: double re,rm; &#125;; 比较合理的解释为，相同class的各个objects之间互为友员。","permalink":"http://skyingzz.github.io/2018/12/03/cpp-param/","photos":[]}]}